.........................................................................................................................................................................................................................................
							  Express.js - Web /Api Framework For node.js
.......................................................................................................................................................................................................................................
What is express?
   Express Fast, unopinionated, minimalist web framework for Node.js
express is built on top of http core module.

What apps can be built using express?

1.RESTFull WebServices

2.Dynamic content generation apps -  spring mvc, .netmvc.   with ui


Core features of Express:
1.Abstraction on core http module
2.lot of apis to send data like json api
3.routers : to create HTTP based web services and apps quickly.
4.middlewares : to extend core framework like - logging, database, security, templates...

Types of distributed Apps:

1.Monolithic App
2.Microservices

Can Express be used to build Microservices?
 No,
Express is just monolithic App framework
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Express Key concepts: in express every thing object
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Objects in express

1.Application
  We call Container object which contain other objects
  entry and exit of an application
  application is created by calling function
2.Request
3.Response
4.Router


1.Application object roll:
	-Routing HTTP requests
	-Configuring middleware
	-Rendering HTML views
	-Registering a template engine


Express Project setup:

1.You can install express dependencies in existing plain node project
2.You can use express cli , to create project structures

Steps:

1.create project folder
2.create src folder
3.npm init
4.install express dependency
5.start writing code

mkdir express-app
cd express-app
npm init
...........................

Installing express framework:
.............................

npm i express --save
npm i nodemon --save-dev

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon src/app.js"
  },
.....................................................................................
				Express- Coding
.....................................................................................

Express : HelloWorld

File Name : app.js - conventional name but you can save index.js as well.

//import express function
const express = require('express')
// console.log(express)

//creating application object
const app = express()

// console.log(app)

//api:
app.get('/hello', (req, res) => {
    //send response
    res.end('Hello Express')
})


//start the server

app.listen(3000, () => {
    console.log('Express Server is Ready!')
})
.................................................................................
			HTTP verbs and CURD
....................................................................................

HTTP Verbs         Operation Type

GET                Read

POST               Write

PUT                Update

DELETE          Remove

URL Pattern:
///////////
Every Http Verbs are mapped against url

/api/customers        -GET ,POST,PUT,DELETE
/api/products
/api/reviews
 
const express = require('express')

const PORT = 3000
const app = express()

//expose apis
//get ===HTTP GET Verb
app.get('/', (req, res) => {
    res.end('Hello Express')
})

//Resource:USERs
app.get('/api/users', (req, res) => {
    res.end('USERS GET')
})
app.post('/api/users', (req, res) => {
    res.end('USERS POST')
})
app.put('/api/users', (req, res) => {
    res.end('USERS PUT')
})
app.delete('/api/users', (req, res) => {
    res.end('USERS DELETE')
})

//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
.........................................................................................................................................................................................................................................
									PORT, getting Server Info
.......................................................................................................................................................................................................................................

const express = require('express')

const PORT = 3000

const app = express()

//expose apis
//get ===HTTP GET Verb
app.get('/', (req, res) => {
    res.end('Hello Express')
})

//Resource:USERs
app.get('/api/users', (req, res) => {
    res.end('USERS GET')
})
app.post('/api/users', (req, res) => {
    res.end('USERS POST')
})
app.put('/api/users', (req, res) => {
    res.end('USERS PUT')
})
app.delete('/api/users', (req, res) => {
    res.end('USERS DELETE')
})

//start server
const server = app.listen(PORT, () => {
    console.log(`Express server is Running at ${server.address().port}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										JSON - payload
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
const express = require('express')
const USERS = require('./mock-data/users')

const PORT = 3000

const app = express()

//expose apis
//get ===HTTP GET Verb
app.get('/', (req, res) => {
    res.end('Hello Express')
})

//Resource:USERs
app.get('/api/users', (req, res) => {
    res.json(USERS)
})
app.post('/api/users', (req, res) => {
    res.end('USERS POST')
})
app.put('/api/users', (req, res) => {
    res.end('USERS PUT')
})
app.delete('/api/users', (req, res) => {
    res.end('USERS DELETE')
})

//start server
const server = app.listen(PORT, () => {
    console.log(`Express server is Running at ${server.address().port}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Service layer, controller, promise
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
const express = require('express')
const { findAll } = require('./services/user.service')

const PORT = 3000
const app = express()

//expose apis
//get ===HTTP GET Verb
app.get('/', (req, res) => {
    res.end('Hello Express')
})

//Resource:USERs
app.get('/api/users', async (req, res) => {
    try {
        const users = await findAll()
        res.json(users)
    }
    catch (err) {
        console.log(err)
    }
})
app.post('/api/users', (req, res) => {
    res.end('USERS POST')
})
app.put('/api/users', (req, res) => {
    res.end('USERS PUT')
})
app.delete('/api/users', (req, res) => {
    res.end('USERS DELETE')
})

//start server
const server = app.listen(PORT, () => {
    console.log(`Express server is Running at ${server.address().port}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Routers
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

src/routers/user.router.js
const express = require('express')
const { findAll } = require('../services/user.service')

const userRouter = express.Router()

userRouter.get('/', async (req, res) => {
    try {
        const users = await findAll()
        res.json(users)
    }
    catch (err) {
        console.log(err)
    }
})


module.exports = userRouter;


src/routers/post.router.js
const express = require('express')

const postRouter = express.Router()

postRouter.get('/', async (req, res) => {
    try {
        res.json({message:'Post Router'})
    }
    catch (err) {
        console.log(err)
    }
})


module.exports = postRouter;

src/routers/comments.router.js
const express = require('express')

const commentsRouter = express.Router()

commentsRouter.get('/', async (req, res) => {
    try {
        res.json({message:'Comments Router'})
    }
    catch (err) {
        console.log(err)
    }
})


module.exports = commentsRouter;

src/app.js
const express = require('express')
//const userRouter = require('./routers/user.router')
const PORT = 3000
const app = express()

//bind Routers with application object, so that application can redirect to routers
// app.use('/api/users',userRouter)
app.use('/api/users', require('./routers/user.router'))
app.use('/api/posts', require('./routers/post.router'))
app.use('/api/comments', require('./routers/comments.router'))

//expose apis
//get ===HTTP GET Verb
app.get('/', (req, res) => {
    res.end('Hello Express')
})

//start server
const server = app.listen(PORT, () => {
    console.log(`Express server is Running at ${server.address().port}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										  Express middlewares
.......................................................................................................................................................................................................................................
What is Middleware?
       Middleware is JavaScript function that have access request object and response and next function in the application request response              cycle.
 The difference between normal function which handles req and response with express , middleware takes third arg

normal function
 app.get('url',(req,res)=>{})

Middleware function
  app.get('url',(req,res,next)=>{
       //pre and post processing
  })
 req and res are objects
 next is a function

The "next" function is a function in the express router which,when invoked,executes the middleware succeeding the current middleware.


Tasks are middleware is doing:

1.Execute any code
2.Make changes to request and response object before handling real req and res cycle.
3.Middlwares can be attached on application object and also router object

use Method
  use method is used to registry middleware.

app.use
router.use

app.use('/api/users', require('./routers/users/user.router'))
 In this code we have registered already middleware which is called as "routerMidleware" - Router itself is middleware.

How to write our own middleware? - Custom Middleware.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Use case: Simple Middleware
const express = require('express')
const PORT = 3000
const app = express()

//middlewares
app.use(function (req, res, next) {
    console.log('Middleware')
    //chain the middleware: move to next
    next()
})


app.get('/', (req, res) => {
    res.end('Hello Express')
})


//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Use case :Multiple Middlewares
const express = require('express')
const PORT = 3000
const app = express()

//middlewares
app.use(function (req, res, next) {
    console.log('M1')
    //chain the middleware: move to next
    next()
})
app.use(function (req, res, next) {
    console.log('M2')
    //chain the middleware: move to next
    next()
})
app.use(function (req, res, next) {
    console.log('M3')
    //chain the middleware: move to next
    next()
})


app.get('/', (req, res) => {
    res.end('Hello Express')
})


//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Use case : Add some custom Header
const express = require('express')
const PORT = 3000
const app = express()

//middlewares
app.use(function (req, res, next) {
    //custom header
    res.set("message", "Hello")
    //chain the middleware: move to next
    next()
})
app.use(function (req, res, next) {
    res.set("name", "Subramanian")

    console.log('M2')
    //chain the middleware: move to next
    next()
})
app.use(function (req, res, next) {
    res.set("company", "IBM")

    console.log('M3')
    //chain the middleware: move to next
    next()
})


app.get('/', (req, res) => {
    res.end('Hello Express')
})


//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
*********************************************************************************************************************************************************
											Middleware for specific URL
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
const express = require('express')
const PORT = 3000
const app = express()

//url specific middleware
app.use('/api/hello', (req, res, next) => {
    res.set('hello', 'helloapi')
    next()
})

app.get('/', (req, res) => {
    res.end('Hello Express')
})

app.get('/api/hello', (req, res) => {
    res.end('Hello-GET')
})
app.post('/api/hello', (req, res) => {
    res.end('Hello-POST')
})
app.put('/api/hello', (req, res) => {
    res.end('Hello-Put')
})
app.delete('/api/hello', (req, res) => {
    res.end('Hello-Delete')
})

app.get('/api/hai', (req, res) => {
    res.end('hai-GET')
})
//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
							        URL and specific method
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
const express = require('express')
const PORT = 3000
const app = express()

//url specific middleware
app.get('/api/hello', (req, res, next) => {
    res.set('hello', 'this is get method')
    next()
})

app.get('/', (req, res) => {
    res.end('Hello Express')
})

app.get('/api/hello', (req, res) => {
    res.end('Hello-GET')
})
app.post('/api/hello', (req, res) => {
    res.end('Hello-POST')
})
app.put('/api/hello', (req, res) => {
    res.end('Hello-Put')
})
app.delete('/api/hello', (req, res) => {
    res.end('Hello-Delete')
})

app.get('/api/hai', (req, res) => {
    res.end('hai-GET')
})
//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								   Routers and middlewares
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
const express = require('express')
const PORT = 3000
const app = express()
//router
const userRouter = express.Router()
app.use('/api/users', userRouter)

//userRouter
// userRouter.use(function (req, res, next) {
//     console.log('User Router')
//     res.set('user', 'this is user Router')
//     next()
// })
// userRouter.use('/', function (req, res, next) {
//     console.log('User Router')
//     res.set('user', 'this is user Router')
//     next()
// })
userRouter.get('/api/users', function (req, res, next) {
    console.log('User Router')
    res.set('user', 'this is user Router')
    next()
})
userRouter.get('/', (req, res) => {
    res.send('User router')
})
userRouter.get('/:id', (req, res) => {
    res.send('User router details')
})


//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
.........................................................................................................................................................................................................................................
		 				 	Can we pass parameters to the Middleware so that we can 
		     					configure middleware - Configurable Middlewares
.......................................................................................................................................................................................................................................

Middleware which takes parameter , it should be higher order function. - function should return another function.

inner function is middleware.

Syntax: without explicit parameter

app.use(function(req,res,next)=>{})

Syntax: with explicit paramter

const mymiddleware = function(param) {

  return function(req,res,next){
     //access param

    next()
  }
}
app.use(mymiddleware('param'))

const express = require('express')
const PORT = 3000
const app = express()

//parametermized middleware
const middleware = function (param) {
    return function (req, res, next) {
        //middleware logic
        console.log(param)
        next()
    }
}
app.use(middleware('hello'))

app.get('/', (req, res) => {
    res.send('Home')
})

//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Use case:
I want to log every request into a file- building logger using middleware

const express = require('express')
const PORT = 3000
const app = express()
const fs = require('node:fs')
const path = require('node:path')

function fileLoggerMiddleware(req, res, next) {
    const logFormat = `[${new Date().toISOString()}] - ${req.method} - ${req.url}\n`
    fs.appendFileSync(path.join(__dirname, 'access.log'), logFormat)
    next()
}
app.use(fileLoggerMiddleware)

app.get('/', (req, res) => {
    res.send('Home')
})
app.get('/api/hello', (req, res) => {
    res.send('Hello')
})
app.get('/api/users', (req, res) => {
    res.send('Users')
})
app.post('/api/products', (req, res) => {
    res.send('products')
})
//start server
app.listen(PORT, () => {
    console.log(`Express server is Running at ${PORT}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									Types of Middlewares
...........................................................................................................................................................................................................................................
1.Application middleware
2.Router level middleware
3.Error handling middleware
4.Third party middleware

1.Application middleware:
  Middleware is attached on application object

2.Router level middleware
->writing router:
 In express except ,request and response , all features including router is middleware.
 Router is in built middleware.


								Error Handling Middleware

const express = require('express')
const app = express()

const PORT = 3000

app.get('/api/user/:name', (req, res) => {
    const name = req.params.name
    if (name === 'admin') {
        res.send({ message: 'Welcome to Admin' })
    } else {
        throw new Error('User Is not valid')
    }
})

//start server
const server = app.listen(PORT, () => {
    console.log(`Express server is ready! at ${server.address().port}`)
})
//server properties

In the above code, the exception is thrown when user is not valid, we have to convert into meaningful  response

Error Handling middleware

What is Error Handling Middleware in Express?

In Express.js, an error-handling middleware is a special middleware function that handles errors across your app.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 Third party Middlewares

Built in middleware or third party middlewares
Middlewares are supplied as part of the express team, open source community.

Common Middlewares From Express Team:

body-parser		Parse HTTP request body.
compression		Compress HTTP responses.
connect-rid		Generate unique request ID.
cookie-parser		Parse cookie header and populate req.cookies. See also cookies.
cookie-session	Establish cookie-based sessions.
cors				Enable cross-origin resource sharing (CORS) with various options.
errorhandler		Development error-handling/debugging.
method-override	Override HTTP methods using header.
morgan			HTTP request logger.
multer			Handle multi-part form data.
response-time		Record HTTP response time.
serve-favicon		Serve a favicon.
serve-index		Serve directory listing for a given path.
serve-static		Serve static files.
session			Establish server-based sessions (development only).
timeout			Set a timeout perioHTTP request processing.
vhost			Create virtual domains.

Every middleware is available as npm dependency.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										bodyParser Middleware
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

bodyParser middleware parses incoming payload(json/formdata), converts into "JavaScript Object"

bodyParser can parse different types of incoming data

JSON body parser - into js object
Raw body parser - into js object
Text body parser - into js object
URL-encoded form body parser - into js object

Steps:

1.install middleware
npm install body-parser

2.configuration as part of application object
const bodyParser = require('body-parser')
app.use(bodyParser.urlencoded())
// parse application/json
app.use(bodyParser.json())

eg:
const express = require('express')
const userRouter = express.Router()

const users = [{
    id: 1,
    name: 'Erik',
    email: 'erik@gmail.com'
},
{
    id: 2,
    name: 'Subramanian',
    email: 'subu@gmail.com'
}]

//findAll
userRouter.get('/', async (req, res) => {
    try {
        res.json(users)
    }
    catch (err) {
        console.log(err)
    }
})
//findById
userRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const user = users.find(u => u.id === id)
        if (!user) {
            //error resonse
            res.status(404).json({ error: 'User Not Found' })
        }
        //throw new Error('something happened')
        res.status(200).json(user)
    }
    catch (err) {
        console.log(err)
        res.status(404).json({ error: err })
    }
})
//save
userRouter.post('/', async (req, res) => {
    try {
        //read payload
        // const payload = req.body
        const { name, email } = req.body
        // const newUser = { id: users.length + 1, name: name, email: email }
        const newUser = { id: users.length + 1, name, email }
        users.push(newUser)
        res.status(201).json(newUser)
    }
    catch (err) {
        console.log(err)
    }
})
//update : PUT /:id
userRouter.put('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const { name, email } = req.body
        const user = users.find(u => u.id === id)
        if (!user) {
            res.status(404).json({ error: 'User Not Found' })
        }
        //update
        user.name = name || user.name
        user.email = email || user.email
        res.json(user)
    }
    catch (err) {
        console.log(err)
    }
})

//Delete
userRouter.delete('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const index = users.findIndex(u => u.id === id)
        if (index === -1) {
            res.status(404).json({ error: 'User Not Found' })
        }
        const deletedUser = users.splice(index, 1)[0]
        res.json(deletedUser)
    }
    catch (err) {
        console.log(err)
        res.status(404).json({ error: err })
    }
})

module.exports = userRouter;

const express = require('express')
const bodyParser = require('body-parser')
const PORT = 3000
const app = express()

//register body parser middleware
app.use(bodyParser.json())

app.use('/api/users', require('./routers/user.router'))
app.use('/api/posts', require('./routers/post.router'))
app.use('/api/comments', require('./routers/comments.router'))

app.get('/', (req, res) => {
    res.end('Hello Express')
})

//start server
const server = app.listen(PORT, () => {
    console.log(`Express server is Running at ${server.address().port}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										CORS - Cross Origin Resource sharing
.........................................................................................................................................................................................................................................


What is CORS?
 Internet browsers usually block access to undefined websites from your services and apis.
 Implementing this module enable your server to share its resources solely with clients who reside in the same domain as yours.

 CORS an HTTP header based mechanism implemented by browsers, enables a server or api to specific any origins

Implementation:
Step 1:
npm install cors

Step 2:
activate cors in app.js via middleware

const cors = require('cors')

app.use(cors()) - enabled for all routes

Enabled for particular route:

app.get('/products/:id', cors(), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for a Single Route'})
})

Note:
 HTTP methods,get,post,delete,update syntax
 
  app.get('url',requestlistener)

  app.get('url',middleware,requestlistener)

Default CORS Configuration values:
{
  "origin": "*",
  "methods": "GET,HEAD,PUT,PATCH,POST,DELETE",
  "preflightContinue": false,
  "optionsSuccessStatus": 204
}

eg
const express = require('express')
const app = express()
const cors = require('cors')

// const corsOptions = {
//     origin: 'http://www.abce.com'
// }
//allow only from this url.
const corsOptions = {
    origin: 'http://127.0.0.1:5500'
}
app.use(cors(corsOptions))

//allow any body to access this app
// app.use(cors())

app.get('/', (req, res) => {
    res.end('Home Page')
})


app.get('/api/customers/:id', (req, res, next) => {
    res.json({ msg: 'cors enabled for only this particular' })
})

//start server
const server = app.listen(3000, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})


Testing:
create index.html
  run this file in vs code with "live server"

How to install live server?
  live server is extensions that should be installed first.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        async function getCustomer() {
            const res = await fetch('http://localhost:3001/api/customers/1')
            const result = await res.json()
            console.log(result)
        }
        getCustomer()
    </script>
</body>

</html>

right click on this file and try to run , from there you can send request.


In the browser console.
content_script_bundle.js:1 Attempting initialization Mon Jul 15 2024 20:48:41 GMT+0530 (India Standard Time)
index.html:1 Access to fetch at 'http://localhost:3001/api/customers/1' from origin 'http://127.0.0.1:5500' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value 'http://www.abce.com' that is not equal to the supplied origin. Have the server send the header with a valid value, or, if an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.Understand this error
index.html:13 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 Logger
.................................................................................................................................................................................................................................

In Express, we have many logger implementation ...

Morgan:
   HTTP request logger middleware for node.js

How to use Morgan

Steps:

npm install morgan

const express = require('express')
const app = express()
const fs = require('node:fs')
const path = require('node:path')
const morgan = require('morgan')

//console log information
// app.use(morgan('dev'))
const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })

app.use(morgan('combined', { stream: accessLogStream }))

app.get('/api/greet',(req,res)=>{
    res.send('Hello')
})

//start server
const server = app.listen(3000, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									express.static middleware
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

To serve static files such as HTML,CSS,js,images and fonts can be served using the built-in middleware called express.static

you dont need to install any dependency.

project structure 

express-app
   src
	public
		index.html
     app.js

const express = require('express')
const app = express()
const fs = require('node:fs')
const path = require('node:path')
const morgan = require('morgan')

const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })
app.use(morgan('combined', { stream: accessLogStream }))
//register to serve static pages : it looks index.html automatically.
app.use(express.static(path.join(__dirname, "public")))


//start server
const server = app.listen(3000, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

ðŸ“Œ It must have 4 parameters:

(err, req, res, next)

Express knows it's for handling errors because of the 4 parameters.

Rules:
1.It must have 4 parameters - err,req,res,next
2.It must be placed after all routers -
	General middlewares are placed at top of the  routers
	Exception Middlewares are place at bottom of the routers

const express = require('express')
const app = express()
const PORT = 3000

app.get('/api/user/:name', (req, res) => {
    const name = req.params.name
    if (name === 'admin') {
        res.send({ message: 'Welcome to Admin' })
    } else {
        throw new Error('User Is not valid')
    }
})
//Error Handling middleware

app.use((err, req, res, next) => {
    console.error(err.message);
    res.status(500).json({
        success: false,
        message: err.message
    });

})

//start server
const server = app.listen(PORT, () => {
    console.log(`Express server is ready! at ${server.address().port}`)
})
//server properties

Handling 404 - Route not  found:
.......................................................

app.use((req, res) => {
  res.status(404).json({
    success: false,
    message: "Route not found",
  });
});
Put this before the global error middleware.

Full Code:
const express = require('express')
const app = express()

const PORT = 3000



app.get('/api/user/:name', (req, res) => {
    const name = req.params.name
    if (name === 'admin') {
        res.send({ message: 'Welcome to Admin' })
    } else {
        throw new Error('User Is not valid')
    }
})

//404 Route not found error handler
//this must be placed before Global error handler
//it wont take next arg, because it terminates the request and response
app.use((req, res) => {
    res.status(404).json({
        success: false,
        message: `The route ${req.originalUrl} not Found`,
    });
});
//Error Handling middleware
app.use((err, req, res, next) => {
    console.error(err.message);

    res.status(500).json({
        success: false,
        message: err.message
    });
})


//start server
const server = app.listen(PORT, () => {
    console.log(`Express server is ready! at ${server.address().port}`)
})
//server properties
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										Externalization of config information
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Some of the information should be externalized like PORT, Database connections ,user names, password.

npm install dotenv --save


express-app(project dir)
 |
.env
	PORT=3000

app.js
const express = require('express')
const app = express()
const fs = require('node:fs')
const path = require('node:path')
const morgan = require('morgan')
//configure .env file into code
// const dotenv = require('dotenv')
// dotenv.config()
require('dotenv').config()

//here we read PORT From enviroment, before that we need to set
const PORT = process.env.PORT || 3000

const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })
app.use(morgan('combined', { stream: accessLogStream }))


app.get('/api/greet', (req, res) => {
    res.send('Hello')
})

//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 Data base Integration
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
 
Now a days data storage is basically classified into two category.

1.SQL Based
2.No SQL Based
  1.Key-value pair
  2.Document based 
  3.column based
  4.graph based

Products 
1.SQL
  Oracle
  Microsoft SQL server
  MySQL
  DB2
  Postgress 
  MariaDB
 etc...

2.NoSQL
 1.Key-value pair
    Redis
 2.Document oriented
   Mongodb
 3.Column based
   Aws dynamo 
 4.Graph based
     neo4j

Note:
 From node.js(express) , we can connect and work with all databases, if there is drivers and apis for those databases

In order to connect with databases, application frameworks offers the frameworks which makes code more simple and abstract database operations

Mongodb frameworks: 
 ODM - Object Document Modeling framework 

Basic Requirements:

1.You need mongodb installed in your local machine

Note: Nobody is installing mongodb /any database locally.

Ways of using mongo(any database)

1.Via docker / PodMan
2.You can use free cloud account for testing


Code:

.env
PORT=3000
DATABASE_URL=mongodb+srv://subugee:subugee222@cluster0.shfpbhv.mongodb.net/myDatabase?retryWrites=true&w=majority&appName=Cluster0
src/models/Post.model.js
const mongoose = require('mongoose')

//delclare schema and later create model
const postSchema = mongoose.Schema({
    title: String,
    content: String
})
//create model and export 
module.exports = mongoose.model("Post", postSchema)

src/services/post.service.js
const Post = require("../models/post.model")

class PostService {

    async save({ title, content }) {
        const newPost = new Post({ title, content })
        //call method of mongoose
        await newPost.save()
        return newPost
    }
    async findAll() {
        return Post.find({})
    }
    async findById(id) {
        const post = await Post.findOne({ _id: id })
        return post
    }
    //update
    async update(id, { title, content }) {
        const post = await Post.findOne({ _id: id })
        if (!post) {
            throw Error()
        }
        if (title) {
            //update title
            post.title = title
        }
        if (content) {
            post.content = content
        }
        //update operations
        await post.save()
        return post
    }
    async remove(id) {
        const post = await Post.findOne({ _id: id })
        if (post) {
            await Post.deleteOne({ _id: id })
        }
        else {
            throw Error("No record is found")
        }
    }
}

module.exports = new PostService()

src/router/post.router.js
const express = require('express')
const { findAll, save, findById, update, remove } = require('../services/post.service')

const postRouter = express.Router()


postRouter.get('/', async (req, res) => {
    try {
        const posts = await findAll()
        res.json(posts)
    }
    catch (err) {
        res.status(404).json({ err })
    }
})
postRouter.post('/', async (req, res) => {
    const post = req.body
    try {
        const savedPost = await save(post)
        res.status(201).json(savedPost)
    }
    catch (err) {
        res.status(400).json({ err })
    }
})
postRouter.get('/:id', async (req, res) => {
    const id = req.params.id
    try {
        const post = await findById(id)
        if (post) {
            res.json(post)
        } else {
            res.json({ message: 'No Post Available' })
        }
    }
    catch (err) {
        res.status(400).json({ err })

    }
})
postRouter.put('/:id', async (req, res) => {
    const id = req.params.id
    const postInput = req.body
    try {
        const post = await update(id, postInput)
        res.json(post)
    }
    catch (err) {
        res.status(404).json({ err })
    }
})
postRouter.delete('/:id', async (req, res) => {
    const id = req.params.id
    try {
        await remove(id)
        res.status(204).send()
    }
    catch (err) {
        res.status(400).json({ err: err.message })
    }
})



module.exports = postRouter

src/app.js
require('dotenv').config()
const express = require('express')
const bodyParser = require('body-parser')
const mongoose = require('mongoose')

const app = express()
const PORT = process.env.PORT || 3000
app.use(bodyParser.json())

async function connectDb() {
    try {
        await mongoose.connect(process.env.DATABASE_URL)
        console.log('Database has been connected')
        // const server = app.listen(PORT, () => {
        //     console.log(server.address())
        //     console.log(`Express is running @ ${server.address().port}`)
        // })
    }
    catch (err) {
        console.log(err)
    }
}
connectDb()

app.use('/api/posts', require('./routers/post.router'))


const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											 Express ,Prisma ,SQL
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Set up Prisma framework:
............................................

Relational databases

Prerequisites
1.an existing Node.js project with a package.json

2.Node.js installed on your machine

3.A database server running and a database with at least one table
  (we are going sqlite db)

create project with all dependency:

 Note: we are going to use in-memory database called sqlite.

\prismaSQL>npm init --yes

npm i express body-parser
npm i nodemon --save-dev
npm install prisma --save-dev
npm install @prisma/client


npx prisma

Prisma is a modern DB toolkit to query, migrate and model your database (https://prisma.io)

Usage

  $ prisma [command]

Commands

            init   Set up Prisma for your app
        generate   Generate artifacts (e.g. Prisma Client)
              db   Manage your database schema and lifecycle
         migrate   Migrate your database
          studio   Browse your data with Prisma Studio
        validate   Validate your Prisma schema
          format   Format your Prisma schema
         version   Displays Prisma version info
           debug   Displays Prisma debug info

Flags

npx prisma init 

creates a new directory called prisma that contains a file called schema.prisma, which contains the Prisma schema with your database connection variable and schema models
creates the .env file in the root directory of the project, which is used for defining environment variables (such as your database connection)


npx prisma init --datasource-provider sqlite

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

.env
PORT=3000

# This was inserted by `prisma init`:
# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

DATABASE_URL="file:./dev.db"
....................................................................................
				connect db
....................................................................................

Already we have connection string defined in ".env" file and provider in prisma.schema
.....................................................................................
				Prisma client

Prima client is object which is responsible for talking to database 

which provides apis for all database operations - CURD operations

npm install @prisma/client

.....................................................................................
				Define model(Entity)
....................................................................................

Model represents table in database.

1.Represent the entities of your application domain
2.Map to the tables (relational databases like PostgreSQL) or collections (MongoDB)   in your database
3.Form the foundation of the queries available in the generated Prisma Client API
4.When used with TypeScript, Prisma Client provides generated type definitions for  your models and any variations of them to make database access entirely type safe.


// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

//define model - describe table structure; database independent
//User is mapped against table
model User {
  // fields- columns
  id    Int     @id @default(autoincrement())
  name  String?
  email String  @unique
}


Database Migration step:

Which creates scripts

npx prisma migrate dev

Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

âˆš Enter a name for the new migration: ... mymigration
Applying migration `20240209080353_mymigration`

The following migration(s) have been created and applied from new schema changes:

migrations/
  â””â”€ 20240209080353_mymigration/
    â””â”€ migration.sql

Your database is now in sync with your schema.

âœ” Generated Prisma Client (v5.9.1) to .\node_modules\@prisma\client in 64ms


Testing :
 Whether all tables are created inside db or not

>npx prisma studio
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											Prisma Client and CURD operations
...........................................................................................................................................................................................................................................

Create Prisma client Object

src/routers/user.router.js

const userRouter = require('express').Router();
const { PrismaClient } = require('@prisma/client')


//create prisma object 
const prisma = new PrismaClient()
//expose api
userRouter.get('/', async (req, res) => {
    try {
        const users = await prisma.user.findMany()
        res.status(200).json(users)
    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }

})
userRouter.post('/', async (req, res) => {
    try {
        const newUser = req.body
        if (newUser) {
            const user = await prisma.user.create({
                data: {
                    email: newUser.email,
                    name: newUser.name
                }
            })
            res.status(201).location("/api/users/save").json(user)
        }
    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }
})
userRouter.get('/:id', async (req, res) => {
    const id = Number(req.params.id)
    try {
        const user = await prisma.user.findUnique({
            where: {
                //id: id
                id
            },
        })
        if (user == null) {
            res.status(401).json({ message: `User not found for ID ${id}` })
        }
        res.status(200).json(user)
    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }
})
userRouter.put('/:id', async (req, res) => {
    try {
        const id = Number(req.params.id)
        const user = req.body
        //update 
        const updateUser = await prisma.user.update({
            where: {
                id: id
            },
            data: {
                name: user.name,
                email: user.email
            }
        })
        if (updateUser) {
            res.status(200).json(updateUser)
        } else {
            res.status(401).json({ message: `Update failed for ${id}` })
        }
    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }
})

userRouter.delete('/:id', async (req, res) => {
    const id = Number(req.params.id)
    try {
        const user = await prisma.user.findUnique({
            where: {
                //id: id
                id
            },
        })
        if (user == null) {
            res.status(401).json({ message: `User not found for ID ${id}` })
        } else {
            await prisma.user.delete({
                where: {
                    id
                },
            })
            res.status(204).end()
        }


    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }
})

module.exports = userRouter

src/app.js
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const PORT = process.env.PORT || 3000

app.use(bodyParser.json())

app.use('/api/users', require('./routers/user.router'))

const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

....................................................................................*****************************************...................................................................................................





